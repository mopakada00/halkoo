<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>How might we?</title>

<!-- Karla -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Karla:wght@400;600&display=swap" rel="stylesheet">

<script src="https://cdn.tailwindcss.com"></script>

<style>
  html, body {
    height: 100vh;
    height: 100dvh; /* Dynamic viewport height for mobile */
    margin: 0;
    padding: 0;
    overflow: hidden;
  }

  body {
    font-family: 'Karla', system-ui, -apple-system, sans-serif;
    display: flex;
    flex-direction: column;
  }

  .viewport {
    overflow: hidden;
    width: 100%;
    flex: 1;
    min-height: 0;
    position: relative;
  }

  .track {
    display: flex;
    gap: 16px;
    transition: transform 1.8s cubic-bezier(0.4, 0, 0.2, 1);
    will-change: transform;
  }

  .perspective {
    perspective: 1200px;
  }

  .viewport {
    --card-width: 220px;
    --card-height: 320px;
  }

  .card {
    width: var(--card-width);
    height: var(--card-height);
    position: relative;
    transform-style: preserve-3d;
    transition: transform 1.6s cubic-bezier(0.4, 0, 0.2, 1), width 0.3s ease, height 0.3s ease;
    border-radius: 8px;
    flex-shrink: 0;
  }

  @media (max-width: 640px) {
    .viewport {
      --card-width: min(200px, calc(100vw - 48px));
      --card-height: min(290px, calc((100vw - 48px) * 1.45));
    }
  }

  .card.flipped {
    transform: rotateY(180deg);
  }

  .face {
    position: absolute;
    inset: 0;
    border-radius: 8px;
    backface-visibility: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 24px;
    text-align: center;
  }

  .front {
    background: white !important;
    transform: rotateY(180deg);
    font-size: 19px;
    font-weight: 400;
    color: #111;
    line-height: 1.2;
    word-wrap: break-word;
    overflow-wrap: break-word;
    flex-direction: column;
    justify-content: space-between;
    padding: 20px;
  }

  .front.pink,
  .front.blue,
  .front.yellow,
  .front.orange {
    background: white !important;
  }


  .card-question {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0 clamp(14px, 4vw, 24px);
  }

  .card-category-wrapper {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: clamp(8px, 2vw, 12px);
    width: 100%;
    background: transparent !important;
  }

  .card-category-wrapper.pink,
  .card-category-wrapper.blue,
  .card-category-wrapper.yellow,
  .card-category-wrapper.orange {
    background: transparent !important;
  }

  .category-line {
    flex: 1;
    height: 3px;
  }

  .card-category-wrapper.pink .category-line {
    background-color: #eb9db7;
  }

  .card-category-wrapper.blue .category-line {
    background-color: #9db7eb;
  }

  .card-category-wrapper.yellow .category-line {
    background-color: #f0d97c;
  }

  .card-category-wrapper.orange .category-line {
    background-color: #eea776;
  }

  .card-category {
    font-size: 14px;
    font-weight: 400;
    color: #525252;
    text-align: center;
    letter-spacing: -0.01em;
    white-space: nowrap;
  }

  /* category colors */
  .pink {
    background: linear-gradient(135deg, #f5b6cc, #eb9db7);
    background-image: url(assets/pinkbg.jpg);
  }
  .blue {
    background: linear-gradient(135deg, #b6ccf5, #9db7eb);
    background-image: url(assets/bluebg.jpg);
  }
  .yellow {
    background: linear-gradient(135deg, #f4e4a6, #f0d97c);
    background-image: url(assets/yellowbg.jpg);
  }
  .orange {
    background: linear-gradient(135deg, #f6c29f, #eea776);
    background-image: url(assets/orangebg.jpg);
  }

  /* Select styling */
  #category {
    appearance: none;
    background-color: #fafafa;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23333' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 16px center;
    padding-right: 40px;
  }
</style>
</head>

<body class="bg-stone-100 flex justify-center px-4 py-4 sm:py-8">

<main class="w-full max-w-sm flex flex-col h-full justify-between py-2 sm:py-4 mx-auto">

  <!-- HEADER -->
  <header class="text-center space-y-5 flex-shrink-0 mb-5 sm:mb-6">
    <div class="space-y-2">
    <div class="items-center w-md">
      <img class="items-center w-md"
      src="assets/logo.png">
    </div>
    <h1 style="font-size:46px; font-weight:600; line-height:1.1; letter-spacing:-0.05em;">
      How might we?
    </h1>
    <p style="font-size:16px; font-weight:400; letter-spacing:-0.02em; color:#525252; line-height:1.2;">
      Kreatywne pytania, ktÃ³re pomagajÄ… spojrzeÄ‡ na problem z nowej perspektywy.
    </p>
    </div>

    <div class="text-left"> 
      <label class="block mb-1 text-[14px] font-semibold text-gray-700">
        Wybierz kategoriÄ™ pytaÅ„:
      </label>
      <select id="category" class="w-full border border-gray-300 rounded-md px-2 py-2">
        <option value="all">ðŸŽ² Wszystkie pytania</option>
        <option value="problem">ðŸ§  ZrozumieÄ‡ problem</option>
        <option value="perspective">ðŸ”„ ZmieniÄ‡ perspektywÄ™</option>
        <option value="ease">ðŸš€ UÅ‚atwiÄ‡ sobie Å¼ycie</option>
        <option value="action">ðŸŽ¯ RuszyÄ‡ do przodu</option>
      </select>
    </div>
>>>>>>> 3a7e73f (Moja pierwsza aktualizacja kodu)
  </header>

  <!-- CARDS -->
  <div class="viewport perspective">
    <div id="track" class="track"></div>
  </div>

  <!-- BUTTON -->
  <button onclick="drawCard()"
    style="font-size:19px; font-weight:600;"
    class="w-full py-4 rounded-full bg-pink-950 text-white flex-shrink-0 mt-4 sm:mt-6">
    Losuj pytanie
  </button>

</main>

<script>
const categories = {
  problem: {
    color: "pink",
    name: "ZrozumieÄ‡ problem",
    questions: [
      "Co tak naprawdÄ™ tutaj nie dziaÅ‚a?",
      "Jaki problem prÃ³bujemy rozwiÄ…zaÄ‡?",
      "Gdzie pojawia siÄ™ najwiÄ™ksza trudnoÅ›Ä‡?",
      "Co jest tu bardziej skomplikowane niÅ¼ powinno?",
      "Co dokÅ‚adnie powoduje frustracjÄ™?",
      "Co jest objawem, a co prawdziwym problemem?",
      "Dlaczego to w ogÃ³le jest problem?",
      "Co dziaÅ‚a gorzej, niÅ¼ siÄ™ spodziewaliÅ›my?"
    ]
  },
  perspective: {
    color: "blue",
    name: "ZmieniÄ‡ perspektywÄ™",
    questions: [
      "Jak spojrzaÅ‚by na to ktoÅ› z zewnÄ…trz?",
      "Co byÅ›my zrobili, gdyby nie byÅ‚o Å¼adnych ograniczeÅ„?",
      "Jak wyglÄ…daÅ‚oby to, gdybyÅ›my zaczÄ™li od zera?",
      "Jak wyglÄ…daÅ‚aby najprostsza wersja tego rozwiÄ…zania?",
      "Co by siÄ™ zmieniÅ‚o, gdyby to nie byÅ‚o takie waÅ¼ne?",
      "Jak wyglÄ…daÅ‚by najgorszy moÅ¼liwy scenariusz?",
      "Jak wyglÄ…daÅ‚by idealny scenariusz?",
      "Jak ktoÅ› inny mÃ³gÅ‚by to rozwiÄ…zaÄ‡?"
    ]
  },
  ease: {
    color: "yellow",
    name: "UÅ‚atwiÄ‡ sobie Å¼ycie",
    questions: [
      "Jak moÅ¼na to uproÅ›ciÄ‡?",
      "Co moÅ¼na usunÄ…Ä‡ zamiast dodawaÄ‡?",
      "Jak zrobiÄ‡ to mniejszym wysiÅ‚kiem?",
      "Jak moÅ¼na to zrobiÄ‡ szybciej?",
      "Co sprawia, Å¼e to jest trudne?",
      "Jak mogÅ‚oby to byÄ‡ mniej mÄ™czÄ…ce?",
      "Jak zrobiÄ‡ to bardziej intuicyjnie?",
      "Co moÅ¼na zautomatyzowaÄ‡ lub pominÄ…Ä‡?"
    ]
  },
  action: {
    color: "orange",
    name: "RuszyÄ‡ do przodu",
    questions: [
      "Jaki jest najmniejszy moÅ¼liwy krok?",
      "Co moÅ¼na zrobiÄ‡ juÅ¼ dziÅ›?",
      "Co stanie siÄ™, jeÅ›li nic nie zrobimy?",
      "Jaka decyzja da najwiÄ™cej efektu?",
      "Od czego najlepiej zaczÄ…Ä‡?",
      "Co moÅ¼na przetestowaÄ‡ bez duÅ¼ego ryzyka?",
      "Jaki ruch odblokuje kolejne kroki?",
      "Co moÅ¼emy zrobiÄ‡ w 10 minut?"
    ]
  }
};

const track = document.getElementById("track");
const select = document.getElementById("category");
let cards = [];

function buildCards() {
  track.innerHTML = "";
  cards = [];

  const selected = select.value;
  const source = selected === "all"
    ? Object.values(categories)
    : [categories[selected]];

  source.forEach(cat => {
    cat.questions.forEach(q => {
      const card = document.createElement("div");
      card.className = `card ${cat.color}`;

      card.innerHTML = `
        <div class="face ${cat.color}"></div>
        <div class="face front ${cat.color}">
          <div class="card-category-wrapper ${cat.color}">
            <span class="category-line"></span>
          </div>
          <div class="card-question">${q}</div>
          <div class="card-category-wrapper ${cat.color}">
            <span class="category-line"></span>
            <span class="card-category">${cat.name}</span>
            <span class="category-line"></span>
          </div>
        </div>
      `;

      track.appendChild(card);
      cards.push(card);
    });
  });

  // Function to scale cards based on available space
  function scaleCards() {
    const viewport = document.querySelector(".viewport");
    if (!viewport) return;

    const viewportHeight = viewport.offsetHeight;
    const viewportWidth = viewport.offsetWidth;
    
    if (viewportHeight === 0 || viewportWidth === 0) return;

    // Base card dimensions
    const baseWidth = 220;
    const baseHeight = 320;
    const aspectRatio = baseHeight / baseWidth; // height/width ratio

    // Calculate optimal size based on available height
    // Leave some padding (about 40px total)
    const availableHeight = Math.max(viewportHeight - 40, 200); // Min 200px available
    const maxHeight = availableHeight;
    
    // Calculate max width, but respect viewport width
    const maxWidth = Math.min(280, viewportWidth - 48);
    const minWidth = 160; // Minimum card width
    
    // Start with height-based calculation
    let cardHeight = Math.min(maxHeight, 420); // Max height 420px
    let cardWidth = cardHeight / aspectRatio;
    
    // If calculated width exceeds max width, scale down based on width
    if (cardWidth > maxWidth) {
      cardWidth = maxWidth;
      cardHeight = cardWidth * aspectRatio;
    }
    
    // If calculated height exceeds available height, scale down
    if (cardHeight > maxHeight) {
      cardHeight = maxHeight;
      cardWidth = cardHeight / aspectRatio;
    }
    
    // Ensure minimum size
    if (cardWidth < minWidth) {
      cardWidth = minWidth;
      cardHeight = cardWidth * aspectRatio;
    }
    
    // Final check: if height still exceeds available space, scale down further
    if (cardHeight > maxHeight) {
      cardHeight = maxHeight;
      cardWidth = cardHeight / aspectRatio;
    }

    // Set CSS custom properties
    viewport.style.setProperty('--card-width', `${cardWidth}px`);
    viewport.style.setProperty('--card-height', `${cardHeight}px`);
  }

  // Function to position cards
  function positionCards() {
    if (cards.length === 0) {
      track.style.transform = "translateX(0)";
      return;
    }

    const viewport = document.querySelector(".viewport");
    if (!viewport) return;

    const viewportWidth = viewport.offsetWidth || 300; // Fallback width
    
    // Force a reflow to ensure cards are measured
    void viewport.offsetHeight;
    
    // Check if cards are measured
    const firstCard = cards[0];
    if (!firstCard) return;

    // Try to get card width, with multiple attempts
    let cardWidth = firstCard.offsetWidth;
    if (cardWidth === 0) {
      // Force layout calculation
      firstCard.style.display = 'block';
      cardWidth = firstCard.offsetWidth || 220; // Fallback to default card width
    }

    const gap = 16;
    const totalCardWidth = cardWidth + gap;
    
    // Center the first card in the viewport
    const offset = (viewportWidth / 2) - (totalCardWidth / 2);
    track.style.transform = `translateX(${offset}px)`;
  }

  // Wait for layout to complete before calculating positions
  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      scaleCards();
      positionCards();
      
      // Additional fallback after a short delay
      setTimeout(() => {
        scaleCards();
        positionCards();
      }, 50);
      
      // Final fallback
      setTimeout(() => {
        scaleCards();
        positionCards();
      }, 200);
    });
  });
}

// Wait for DOM to be ready and ensure cards are visible
function initializeCards() {
  buildCards();
  // Ensure cards are scaled and positioned after a brief delay to account for any rendering
  setTimeout(() => {
    if (cards.length > 0) {
      scaleCards();
      positionCards();
    }
  }, 100);
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeCards);
} else {
  initializeCards();
}

select.addEventListener("change", () => {
  buildCards();
  // Scale cards after rebuilding
  setTimeout(() => {
    scaleCards();
    positionCards();
  }, 100);
});

// Recalculate on resize for mobile orientation changes
let resizeTimeout;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(() => {
    scaleCards();
    positionCards();
  }, 250);
});

function drawCard() {
  if (!cards.length) return;

  // Smoothly unflip all cards first
  cards.forEach(c => c.classList.remove("flipped"));
  
  // Wait for unflip animation to complete before moving
  setTimeout(() => {
    const picked = cards[Math.floor(Math.random() * cards.length)];
    const index = cards.indexOf(picked);

    // Ensure layout is complete before calculating
    requestAnimationFrame(() => {
      const viewportWidth = document.querySelector(".viewport").offsetWidth;
      const cardWidth = picked.offsetWidth + 16;

      const offset =
        (index * cardWidth) - (viewportWidth / 2) + (cardWidth / 2);

      track.style.transform = `translateX(${-offset}px)`;

      setTimeout(() => {
        picked.classList.add("flipped");
      }, 1200);
    });
  }, 300);
}

// Touch/swipe functionality to draw cards
let touchStartX = 0;
let touchEndX = 0;
let isDragging = false;
let dragStartX = 0;
let currentTransform = 0;

function getCurrentTransform() {
  const trackElement = document.getElementById("track");
  if (!trackElement) return 0;
  const transform = trackElement.style.transform;
  const match = transform.match(/translateX\((-?\d+\.?\d*)px\)/);
  return match ? parseFloat(match[1]) : 0;
}

function handleTouchStart(e) {
  touchStartX = e.touches ? e.touches[0].clientX : e.clientX;
  dragStartX = touchStartX;
  currentTransform = getCurrentTransform();
  isDragging = true;
  const trackElement = document.getElementById("track");
  if (trackElement) {
    trackElement.style.transition = 'none';
  }
}

function handleTouchMove(e) {
  if (!isDragging) return;
  
  const currentX = e.touches ? e.touches[0].clientX : e.clientX;
  const diff = currentX - dragStartX;
  const newTransform = currentTransform + diff;
  const trackElement = document.getElementById("track");
  if (trackElement) {
    trackElement.style.transform = `translateX(${newTransform}px)`;
  }
}

function handleTouchEnd(e) {
  if (!isDragging) return;
  
  isDragging = false;
  const trackElement = document.getElementById("track");
  if (trackElement) {
    trackElement.style.transition = 'transform 1.8s cubic-bezier(0.4, 0, 0.2, 1)';
  }
  
  touchEndX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
  const swipeDistance = touchEndX - touchStartX;
  const swipeThreshold = 50; // Minimum swipe distance
  
  // If swiped significantly, draw a new card
  if (Math.abs(swipeDistance) > swipeThreshold) {
    drawCard();
  } else {
    // Otherwise, snap back to current position
    positionCards();
  }
}

// Initialize swipe functionality after DOM is ready
function initSwipe() {
  const viewport = document.querySelector(".viewport");
  if (viewport) {
    viewport.addEventListener('touchstart', handleTouchStart, { passive: true });
    viewport.addEventListener('touchmove', handleTouchMove, { passive: true });
    viewport.addEventListener('touchend', handleTouchEnd, { passive: true });
    
    // Also support mouse drag for desktop
    viewport.addEventListener('mousedown', handleTouchStart);
    viewport.addEventListener('mousemove', (e) => {
      if (isDragging) handleTouchMove(e);
    });
    viewport.addEventListener('mouseup', handleTouchEnd);
    viewport.addEventListener('mouseleave', handleTouchEnd);
  }
}

// Initialize swipe when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initSwipe);
} else {
  initSwipe();
}
</script>

</body>
</html>
