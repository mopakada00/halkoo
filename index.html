<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>How might we?</title>

<!-- Karla -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Karla:wght@400;600&display=swap" rel="stylesheet">

<script src="https://cdn.tailwindcss.com"></script>
<link rel="stylesheet" href="style.css">

</head>

<body class="bg-[#F9F5F1] flex justify-center px-4 py-4 sm:py-8">

  <div
  id="welcome-modal"
  class="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-md hidden"
>
  <div
    class="bg-white rounded-2xl max-w-sm w-[90%] shadow-2xl overflow-hidden"
  >
    <!-- HEADER: OBRAZEK 3:1 -->
    <div class="w-full aspect-[3/1]">
      <img
        src="assets/modalpic.png"
        alt="Welcome"
        class="w-full h-full object-cover"
      />
    </div>

    <!-- CONTENT -->
    <div class="p-6 text-center">
      <h2 class="mb-4 font-semibold tracking-tight text-gray-900
      text-[clamp(20px,5vw,28px)] whitespace-nowrap">
        Witaj w "How Might We"!
      </h2>

      <div
        class="text-gray-600 space-y-4 mb-8 text-left text-[14px] tracking-normal leading-5"
      >
        <p>
          Ta aplikacja to Twoje narzÄ™dzie do
          <strong>kreatywnego rozwiÄ…zywania problemÃ³w</strong>.
        </p>
        <ul class="list-decimal pl-5 space-y-2">
          <li>Wybierz kategoriÄ™, ktÃ³ra CiÄ™ interesuje.</li>
          <li>Wylosuj kartÄ™ z pytaniem za pomocÄ… przycisku lub przewiniÄ™cia palcem.</li>
          <li>SpÃ³jrz na swoje wyzwanie z zupeÅ‚nie innej perspektywy.</li>
        </ul>
      </div>

      <button
        onclick="closeModal()"
        class="w-full py-3 bg-pink-950 text-white font-semibold rounded-full hover:bg-pink-900 transition-colors"
      >
        Zaczynamy!
      </button>
    </div>
  </div>
</div>

<main class="w-full max-w-sm flex flex-col h-full justify-between py-2 sm:py-4 mx-auto">

  <!-- HEADER -->
  <header class="text-center space-y-5 flex-shrink-0 mb-5 sm:mb-6">
    <div class="space-y-2">
    <h1 style="font-size:50px; font-weight:600; line-height:1.1; letter-spacing:-0.05em;">
      How might we?
    </h1>
    <p style="font-size:16px; font-weight:400; letter-spacing:-0.02em; color:#525252; line-height:1.2;">
      Kreatywne pytania, ktÃ³re pomagajÄ… spojrzeÄ‡ na problem z nowej perspektywy.
    </p>
    </div>

    <div class="text-left"> 
      <label class="block mb-1 text-[14px] font-semibold text-gray-700">
        Kategoria pytaÅ„
      </label>
      <select id="category" class="w-full border border-gray-300 rounded-md px-2 py-2">
        <option value="all">ðŸŽ² Wszystkie pytania</option>
        <option value="problem">ðŸ§  ZrozumieÄ‡ problem</option>
        <option value="perspective">ðŸ”„ ZmieniÄ‡ perspektywÄ™</option>
        <option value="ease">ðŸš€ UÅ‚atwiÄ‡ sobie Å¼ycie</option>
        <option value="action">ðŸŽ¯ RuszyÄ‡ do przodu</option>
      </select>
    </div>
  </header>

  <!-- CARDS -->
  <div class="viewport perspective">
    <div id="track" class="track"></div>
  </div>

  <!-- BUTTON -->
  <button onclick="drawCard()"
    style="font-size:19px; font-weight:600;"
    class="w-full py-4 rounded-full bg-[#570301] text-white flex-shrink-0 mt-4 sm:mt-6">
    Losuj pytanie
  </button>

</main>

<script>
const categories = {
  problem: {
    color: "pink",
    name: "ZrozumieÄ‡ problem",
    questions: [
      "Co tak naprawdÄ™ tutaj nie dziaÅ‚a?",
      "Jaki problem prÃ³bujemy rozwiÄ…zaÄ‡?",
      "Gdzie pojawia siÄ™ najwiÄ™ksza trudnoÅ›Ä‡?",
      "Co jest tu bardziej skomplikowane niÅ¼ powinno?",
      "Co dokÅ‚adnie powoduje frustracjÄ™?",
      "Co jest objawem, a co prawdziwym problemem?",
      "Dlaczego to w ogÃ³le jest problem?",
      "Co dziaÅ‚a gorzej, niÅ¼ siÄ™ spodziewaliÅ›my?"
    ]
  },
  perspective: {
    color: "blue",
    name: "ZmieniÄ‡ perspektywÄ™",
    questions: [
      "Jak spojrzaÅ‚by na to ktoÅ› z zewnÄ…trz?",
      "Co byÅ›my zrobili, gdyby nie byÅ‚o Å¼adnych ograniczeÅ„?",
      "Jak wyglÄ…daÅ‚oby to, gdybyÅ›my zaczÄ™li od zera?",
      "Jak wyglÄ…daÅ‚aby najprostsza wersja tego rozwiÄ…zania?",
      "Co by siÄ™ zmieniÅ‚o, gdyby to nie byÅ‚o takie waÅ¼ne?",
      "Jak wyglÄ…daÅ‚by najgorszy moÅ¼liwy scenariusz?",
      "Jak wyglÄ…daÅ‚by idealny scenariusz?",
      "Jak ktoÅ› inny mÃ³gÅ‚by to rozwiÄ…zaÄ‡?"
    ]
  },
  ease: {
    color: "yellow",
    name: "UÅ‚atwiÄ‡ sobie Å¼ycie",
    questions: [
      "Jak moÅ¼na to uproÅ›ciÄ‡?",
      "Co moÅ¼na usunÄ…Ä‡ zamiast dodawaÄ‡?",
      "Jak zrobiÄ‡ to mniejszym wysiÅ‚kiem?",
      "Jak moÅ¼na to zrobiÄ‡ szybciej?",
      "Co sprawia, Å¼e to jest trudne?",
      "Jak mogÅ‚oby to byÄ‡ mniej mÄ™czÄ…ce?",
      "Jak zrobiÄ‡ to bardziej intuicyjnie?",
      "Co moÅ¼na zautomatyzowaÄ‡ lub pominÄ…Ä‡?"
    ]
  },
  action: {
    color: "orange",
    name: "RuszyÄ‡ do przodu",
    questions: [
      "Jaki jest najmniejszy moÅ¼liwy krok?",
      "Co moÅ¼na zrobiÄ‡ juÅ¼ dziÅ›?",
      "Co stanie siÄ™, jeÅ›li nic nie zrobimy?",
      "Jaka decyzja da najwiÄ™cej efektu?",
      "Od czego najlepiej zaczÄ…Ä‡?",
      "Co moÅ¼na przetestowaÄ‡ bez duÅ¼ego ryzyka?",
      "Jaki ruch odblokuje kolejne kroki?",
      "Co moÅ¼emy zrobiÄ‡ w 10 minut?"
    ]
  }
};

const track = document.getElementById("track");
const select = document.getElementById("category");
let cards = [];

function buildCards() {
  track.innerHTML = "";
  cards = [];

  const selected = select.value;
  const source = selected === "all"
    ? Object.values(categories)
    : [categories[selected]];

  source.forEach(cat => {
    cat.questions.forEach(q => {
      const card = document.createElement("div");
      card.className = `card ${cat.color}`;

      card.innerHTML = `
        <div class="face ${cat.color}"></div>
        <div class="face front ${cat.color}">
          <div class="card-category-wrapper ${cat.color}">
            <span class="category-line"></span>
          </div>
          <div class="card-question">${q}</div>
          <div class="card-category-wrapper ${cat.color}">
            <span class="category-line"></span>
            <span class="card-category">${cat.name}</span>
            <span class="category-line"></span>
          </div>
        </div>
      `;

      track.appendChild(card);
      cards.push(card);
    });
  });

  // Function to scale cards based on available space
  function scaleCards() {
    const viewport = document.querySelector(".viewport");
    if (!viewport) return;

    const viewportHeight = viewport.offsetHeight;
    const viewportWidth = viewport.offsetWidth;
    
    if (viewportHeight === 0 || viewportWidth === 0) return;

    // Base card dimensions
    const baseWidth = 220;
    const baseHeight = 320;
    const aspectRatio = baseHeight / baseWidth; // height/width ratio

    // Calculate optimal size based on available height
    // Leave some padding (about 40px total)
    const availableHeight = Math.max(viewportHeight - 40, 200); // Min 200px available
    const maxHeight = availableHeight;
    
    // Calculate max width, but respect viewport width
    const maxWidth = Math.min(280, viewportWidth - 48);
    const minWidth = 160; // Minimum card width
    
    // Start with height-based calculation
    let cardHeight = Math.min(maxHeight, 420); // Max height 420px
    let cardWidth = cardHeight / aspectRatio;
    
    // If calculated width exceeds max width, scale down based on width
    if (cardWidth > maxWidth) {
      cardWidth = maxWidth;
      cardHeight = cardWidth * aspectRatio;
    }
    
    // If calculated height exceeds available height, scale down
    if (cardHeight > maxHeight) {
      cardHeight = maxHeight;
      cardWidth = cardHeight / aspectRatio;
    }
    
    // Ensure minimum size
    if (cardWidth < minWidth) {
      cardWidth = minWidth;
      cardHeight = cardWidth * aspectRatio;
    }
    
    // Final check: if height still exceeds available space, scale down further
    if (cardHeight > maxHeight) {
      cardHeight = maxHeight;
      cardWidth = cardHeight / aspectRatio;
    }

    // Set CSS custom properties
    viewport.style.setProperty('--card-width', `${cardWidth}px`);
    viewport.style.setProperty('--card-height', `${cardHeight}px`);
  }

  // Function to position cards
  function positionCards() {
    if (cards.length === 0) {
      track.style.transform = "translateX(0)";
      return;
    }

    const viewport = document.querySelector(".viewport");
    if (!viewport) return;

    const viewportWidth = viewport.offsetWidth || 300; // Fallback width
    
    // Force a reflow to ensure cards are measured
    void viewport.offsetHeight;
    
    // Check if cards are measured
    const firstCard = cards[0];
    if (!firstCard) return;

    // Try to get card width, with multiple attempts
    let cardWidth = firstCard.offsetWidth;
    if (cardWidth === 0) {
      // Force layout calculation
      firstCard.style.display = 'block';
      cardWidth = firstCard.offsetWidth || 220; // Fallback to default card width
    }

    const gap = 16;
    const totalCardWidth = cardWidth + gap;
    
    // Center the first card in the viewport
    const offset = (viewportWidth / 2) - (totalCardWidth / 2);
    track.style.transform = `translateX(${offset}px)`;
  }

  // Wait for layout to complete before calculating positions
  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      scaleCards();
      positionCards();
      
      // Additional fallback after a short delay
      setTimeout(() => {
        scaleCards();
        positionCards();
      }, 50);
      
      // Final fallback
      setTimeout(() => {
        scaleCards();
        positionCards();
      }, 200);
    });
  });
}

// Wait for DOM to be ready and ensure cards are visible
function initializeCards() {
  buildCards();
  // Ensure cards are scaled and positioned after a brief delay to account for any rendering
  setTimeout(() => {
    if (cards.length > 0) {
      scaleCards();
      positionCards();
    }
  }, 100);
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeCards);
} else {
  initializeCards();
}

select.addEventListener("change", () => {
  buildCards();
  // Scale cards after rebuilding
  setTimeout(() => {
    scaleCards();
    positionCards();
  }, 100);
});

// Recalculate on resize for mobile orientation changes
let resizeTimeout;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(() => {
    scaleCards();
    positionCards();
  }, 250);
});

function drawCard() {
  if (!cards.length) return;

  // Smoothly unflip all cards first
  cards.forEach(c => c.classList.remove("flipped"));
  
  // Wait for unflip animation to complete before moving
  setTimeout(() => {
    const picked = cards[Math.floor(Math.random() * cards.length)];
    const index = cards.indexOf(picked);

    // Ensure layout is complete before calculating
    requestAnimationFrame(() => {
      const viewportWidth = document.querySelector(".viewport").offsetWidth;
      const cardWidth = picked.offsetWidth + 16;

      const offset =
        (index * cardWidth) - (viewportWidth / 2) + (cardWidth / 2);

      track.style.transform = `translateX(${-offset}px)`;

      setTimeout(() => {
        picked.classList.add("flipped");
      }, 1200);
    });
  }, 300);
}

// Touch/swipe functionality to draw cards
let touchStartX = 0;
let touchEndX = 0;
let isDragging = false;
let dragStartX = 0;
let currentTransform = 0;

function getCurrentTransform() {
  const trackElement = document.getElementById("track");
  if (!trackElement) return 0;
  const transform = trackElement.style.transform;
  const match = transform.match(/translateX\((-?\d+\.?\d*)px\)/);
  return match ? parseFloat(match[1]) : 0;
}

function handleTouchStart(e) {
  touchStartX = e.touches ? e.touches[0].clientX : e.clientX;
  dragStartX = touchStartX;
  currentTransform = getCurrentTransform();
  isDragging = true;
  const trackElement = document.getElementById("track");
  if (trackElement) {
    trackElement.style.transition = 'none';
  }
}

function handleTouchMove(e) {
  if (!isDragging) return;
  
  const currentX = e.touches ? e.touches[0].clientX : e.clientX;
  const diff = currentX - dragStartX;
  const newTransform = currentTransform + diff;
  const trackElement = document.getElementById("track");
  if (trackElement) {
    trackElement.style.transform = `translateX(${newTransform}px)`;
  }
}

function handleTouchEnd(e) {
  if (!isDragging) return;
  
  isDragging = false;
  const trackElement = document.getElementById("track");
  if (trackElement) {
    trackElement.style.transition = 'transform 1.8s cubic-bezier(0.4, 0, 0.2, 1)';
  }
  
  touchEndX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
  const swipeDistance = touchEndX - touchStartX;
  const swipeThreshold = 50; // Minimum swipe distance
  
  // If swiped significantly, draw a new card
  if (Math.abs(swipeDistance) > swipeThreshold) {
    drawCard();
  } else {
    // Otherwise, snap back to current position
    positionCards();
  }
}

// Initialize swipe functionality after DOM is ready
function initSwipe() {
  const viewport = document.querySelector(".viewport");
  if (viewport) {
    viewport.addEventListener('touchstart', handleTouchStart, { passive: true });
    viewport.addEventListener('touchmove', handleTouchMove, { passive: true });
    viewport.addEventListener('touchend', handleTouchEnd, { passive: true });
    
    // Also support mouse drag for desktop
    viewport.addEventListener('mousedown', handleTouchStart);
    viewport.addEventListener('mousemove', (e) => {
      if (isDragging) handleTouchMove(e);
    });
    viewport.addEventListener('mouseup', handleTouchEnd);
    viewport.addEventListener('mouseleave', handleTouchEnd);
  }
}

// Initialize swipe when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initSwipe);
} else {
  initSwipe();
}

function checkFirstVisit() {
  const hasVisited = localStorage.getItem('hasVisitedHMW');
  if (!hasVisited) {
    document.getElementById('welcome-modal').classList.remove('hidden');
  }
}

function closeModal() {
  document.getElementById('welcome-modal').classList.add('hidden');
  localStorage.setItem('hasVisitedHMW', 'true');
}

// Uruchom sprawdzenie po zaÅ‚adowaniu strony
window.addEventListener('DOMContentLoaded', checkFirstVisit);
</script>

</body>
</html>
